1. in a class, immutable objects at different places are actually the same object if their values is the same

2. correct way of implemeting deep copy

	cls = self.__class__
	result = cls.__new__(cls)
	memo[id(self)] = result
	for key, value in self.__dict__.items():
		result.__dict__[key] = deepcopy(value, memo)
	return result

3. __var will be maglined by compiler

4. _var is a private member of class which is an agreement/advise upon python

5. _ is a temporary var

6. immutable objects are not deep-copiable

7. using struct.pack to make raw object to accomplish memcpy in C

8. using typing is heavy as of python3.7

9. methods to solve the problem that an annotation can not be used before class is defined:
	
	from __future__ import annotations
		this will store annotations as strings
	
	use a string
		example:
		class X():
			...
			def x() -> 'X':
				...

	in python 4.0, this is not an issue

10. in python3, super() is equivalent to super(<containing class>, self)
	i.e. super() is super(A, self)

11. with value as target:
		suite
	
	equals to

	try:
		target = value
		suite
	except:
	    hit_except = True
	    if not exit(manager, *sys.exc_info()):
	        raise
	finally:
	    if not hit_except:
	        exit(manager, None, None, None)

	for a lock object l, with statement roughly equals to

	try:
		l.acquire()
		suite
	finally:
		l.release()

12. lists are thread-safe because of GIL protecting against concurrent
	access.
	However, not-atomic operations of list are not safe,
	which means lists themselves will never ever corrupt,
	but their data might be.
	A few of operations are safe:
		append():
			even though PyList_Append() is reading from memory,
			GIL prevents from concurrent access:
				1. data cannot be written at the same place at the same time by multiple threads
				2. that piece of memory is protected while reading
			Thus, we could assure that append() is thread safe


13. mixinclass super inheritance
		example:
			class Foo():
				def __init__(self, **kwargs):
					super().__init__(**kwargs)			# forwards all unused arguments
			
			class Bar():
				def __init__(self, bar, **kwargs):		
					super().__init__(**kwargs)			# forwards all unused arguments
			
			class FooBar(Foo, Bar):
				def __init__(**kwargs):
					super().__init__(**kwargs)			# forwards all unused arguments

		mixin classes are usually abstract-like class, their objects cannot call methods
		they are used for overriding methods in python


14. don't rely on python built-in GIL
	it could be changed anytime
	and cost of additional lock is negligible if GIL is already there
	but with additional lock it is much safer

15. c++ const expression:
		expression can be evaluated at compile time
		such expressions can be used as non-type template atguments, array sizes, and
		in other contexts that require constant expressions
		example:
			int n = 1;
			std::array<int, n> a1; // error: n is not a constant expression
			const int cn = 2;
			std::array<int, cn> a2; // OK: cn is a constant expression

	core const expression:
	expressions cannot be evaluated:

		this pointer, except in a constexpr or a constexpr constructor

		functions that are not declared constexpr:
			
			constexpr int m = std::time(nullptr); // Error: std::time() is not constexpr

		functions that are declared, but not defined
			
			int x, y, z[30];
			constexpr auto e1 = &y - &x; // Error: undefined

		constexpr template instantiation where instantiation fails to satisify constexpr requirements
			
			constexpr double d2 = 2.0/0.0; // Error: not defined

		a function call to a constexpr virtual function, invoked on an object not usable in constant expressions (see below) and whose lifetime began outside this expression.

		an expression that would exceed the implementation-defined limits

		an expression whose evaluation leads to any form of core language undefined behavior (including signed integer overflow, division by zero, pointer arithmetic outside array bounds, etc). Whether standard library undefined behavior is detected is unspecified.
			
			constexpr double d2 = 2.0/0.0; // Error: not defined
		
		a lambda expression

		a lvalue-to-rvalue implicit conversation unless
			1. applied to non-volatile glvalue that designates an object that is usable in constant expresssions
				int main() {
				    const std::size_t tabsize = 50;
				    int tab[tabsize]; // OK: tabsize is a constant expression
				                      // because tabsize is usable in constant expressions
				                      // because it has const-qualified integral type, and
				                      // its initializer is a constant initializer
				 
				    std::size_t n = 50;
				    const std::size_t sz = n;
				    int tab2[sz]; // error: sz is not a constant expression
				                  // because sz is not usable in constant expressions
				                  // because its initializer was not a constant initializer
				}
			2. or applied to a non-volatile glvalue of literal type that refers to a non-volatile object whose lifetime began within the evaluation of this expression

		an lvalue-to-rvalue implicit conversion or modification applied to a non-active member of a union or its subobject (even if it shares a common initial sequence with the active member)

16. lvalue, xvalue, glvalue, rvalue, prvalue
	lvalue: function or object itself, which has memory location
	xvalue: objects are near the end of lifetime
			result of certain expressions involving rvalue references
	glvalue: lvalue or xvalue
	rvalue: temporary object, a value, or subobject thereof
	prvalue: rvalue that is not xvalue

	note that rvalue reference is lvalue